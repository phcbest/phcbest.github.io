---
layout: article
title: Android问道--应用程序进程的启动过程
tags: Android
---

# 应用程序进程简介

当我们想要启动一个应用程序的时候,首先要保证该应用程序所需的进程时候已经启动,AMS在启动应用程序的时候会检测这应用程序需要的进程是否存在,不存在的话就会请求Zygote进程启动所需的进程,在Android系统启动的文章中我们知道了Zygote的Java层会创建一个Service端的Socket,该Socket用来等待AMS请求Zygote创建新的应用程序进程,Zygote进程通过Fock自身来创建应用程序进程,这样应用程序进程就获得了Zygote进程在启动时创建的虚拟机实例,应用程序进程创建过程中还创建了Binder线程池和消息循环,这样进程中的程序就可以使用Binder进行进程间通信了

# 应用程序进程启动过程介绍

应用程序进程创建过程的步骤比较多,分为两个部分解析分别是AMS发送启动应用程序进程的请求和Zygote接受请求并创建应用程序进程

## AMS发送启动应用程序进程请求

*启动过程的时序图*

```mermaid
sequenceDiagram
	某段想要开启进程的逻辑->>AMS: startProcessLocked
	activate AMS
	AMS->>ZygoteProcess: start
	deactivate AMS
    activate ZygoteProcess
    ZygoteProcess ->> ZygoteProcess: startViaZygote
    ZygoteProcess ->> ZygoteProcess: zygoteSendArgsAndGetResult
    ZygoteProcess ->> ZygoteProcess: openZygoteSocketIfNeeded
    deactivate ZygoteProcess
	activate ZygoteState
	ZygoteProcess ->> ZygoteState: connect    
	deactivate ZygoteState
```

AMS如果想要启动应用程序进程,就需要向Zygote进程发送**请求创建应用程序进程**的请求,AMS会通过调用**startProcessLocked**方法向Zygote进程发送请求

- startProcessLocked位于AMS类中

- 获取需要创建的应用程序进程的用户ID `int uid = app.uid;`

- 对gids进行创建和赋值，gids是用户组ID，可以方便应用程序共享一些资源

  ```java
                  if (ArrayUtils.isEmpty(permGids)) {
                      gids = new int[3];
                  } else {
                      gids = new int[permGids.length + 3];
                      System.arraycopy(permGids, 0, gids, 3, permGids.length);
                  }
                  gids[0] = UserHandle.getSharedAppGid(UserHandle.getAppId(uid));
                  gids[1] = UserHandle.getCacheAppGid(UserHandle.getAppId(uid));
                  gids[2] = UserHandle.getUserGid(UserHandle.getUserId(uid));
  ```

- 如果entryPrint为null，给其赋值 `if (entryPoint == null) entryPoint = "android.app.ActivityThread";`这个值是应用程序进程主线程的类名。

- 启动应用程序进程`startResult = Process.start(entryPoint,app.processName, uid, uid, gids, debugFlags, mountExternal,app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,app.info.dataDir, invokeWith, entryPointArgs);` 将得到的id个gis传递过去

- 在Process类*(位于frameworks\base\core\java\android\os)*的start方法中,调用了ZygoteProcess的Start方法,这个类是用来保持与Zygote进程的通信状态

- ZygoteProcess位于Process类的同级目录下,在其start方法中,主要是调用了**ZygoteProcess.startViaZygote**方法

- 在startViaZygote方法中创建了字符串列表**argsForZygote**,并且将应用进程启动参数保存在**argsForZygote**中

- 在startViaZygote方法最后调用了`return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);`,我们调用了**openZygoteSocketIfNeeded**方法返回了一个**ZygoteState**的实例作为调用**zygoteSendArgsAndGetResult方法**的第一个参数,第二个参数为之前打包好的argsForZygote启动参数

  > **zygoteSendArgsAndGetResult**方法主要是将传入的应用进程启动参数**argsForZygote**写入ZygoteState中,在该方法中,ZygoteState是ZygoteProcess的静态内部类,用来表示和Zygote的通信状态,ZygoteState是由**openZygoteSocketIfNeeded**返回的,在这个方法中执行了以下代码
  >
  > - 和Zygote进程建立Socket连接`primaryZygoteState = ZygoteState.connect(mSocket);`返回一个ZygoteState类型的参数
  > - 判断Zygote主模式返回的ZygoteState是否**和当前启动应用程序进程所需的ABI匹配**`if(primaryZygoteState.matches(abi))`
  > - 如果不匹配,尝试连接Zygote辅模式`secondaryZygoteState = ZygoteState.connect(mSecondarySocket);`
  > - 判断辅模式返回的Zygote辅模式返回的ZygoteState是否和当前启动应用程序进程所需的ABI匹配`secondaryZygoteState.matches(abi)`
  > - 如果主模式和辅模式都不匹配,抛出**ZygoteStartFailedEx**异常

## Zygote接收请求并创建应用程序进程

Socket连接成功并且匹配ABI之后会返回ZygoteState类型的对象,我们当时将应用程序的启动参数**argsForZygote**写入了ZygoteState中,这样Zygote进程会受到一个创建新进程的请求,时序图如下

```mermaid
sequenceDiagram
	开始执行 ->> ZygoteInit:main
	activate ZygoteInit
	ZygoteInit ->> ZygoteServer:renselectLoop
	deactivate ZygoteInit
	activate ZygoteServer
	ZygoteServer ->> ZygoteConnection:runOnce
	deactivate ZygoteServer
	activate ZygoteConnection
	ZygoteConnection ->> ZygoteConnection:HandleChildProc
	deactivate ZygoteConnection
	ZygoteConnection ->> ZygoteInit:zygoteInit
	activate ZygoteInit
	ZygoteInit ->> RuntimeInit:applicationInit
	deactivate ZygoteInit
	activate RuntimeInit
	RuntimeInit ->> RuntimeInit:invokeStaticMain
	deactivate RuntimeInit
	RuntimeInit -->> ZygoteInit:methodAndArgsCaller
	activate ZygoteInit
	ZygoteInit ->>ActivityThread:main
	deactivate ZygoteInit
	activate ActivityThread
	deactivate ActivityThread
```

