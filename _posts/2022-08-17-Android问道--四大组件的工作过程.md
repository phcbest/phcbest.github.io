---
layout: article
title: Android问道--四大组件的工作过程
tags: Android 
---

# 序言

在之前的两篇文章中介绍了系统启动的过程和应用程序进程的启动过程,应用程序进程启动后就该启动应用程序了,也就是启动**根Activity**

四大组件是应用开发中最常接触的,活动,服务,广播接收器,内容提供者,这篇文章会深入介绍它们的工作过程,四大组件的工作过程和**插件化**技术有所关联

# 根Activity的启动过程

Activity的启动过程分为两种,一种是根Activity的启动过程,一种是普通Activity的启动过程,**根Activity指的是应用程序启动的第一个Activity**,因此根Activity的启动过程可以理解为应用程序的启动过程,普通Activity指的是除了根Activity以外的Activity,根Activity和普通Activity启动是由重叠部分的,根Activity更为典型

根Activity启动过程较为繁琐,主要是分为三个部分

- **Launcher请求AMS**
- **AMS到ApplicationThread的调用**
- **ActivityThread启动Activity**

## Launcher请求AMS过程

Launcher启动后会将已经安装好的Application快捷图标显示到桌面上,这些快捷图标就是根Activity的入口,当我们点击某个应用程序的快捷图标时,会通过Launcher请求AMS来启动该应用程序,时序图如下所示

```mermaid
sequenceDiagram
	用户点击 ->> Launcher : startActivitySafely
    activate Launcher
	Launcher ->> Activity : startActivity
	deactivate Launcher
	activate Activity
	Activity ->> Activity : startActivityForResult
	Activity ->> Instrumentation : execStartActivity
	deactivate Activity
	activate Instrumentation
	Instrumentation ->> IActivityManager : startActivity
	deactivate Instrumentation
	activate IActivityManager
	IActivityManager ->> AMS : startActivity
	deactivate IActivityManager
	activate AMS
	deactivate AMS
```

当点击应用程序的快捷图标时,调用Launcher的startActivitySafely方法

> Launcher类位于packages\apps\Launcher3\src\com\android\launcher3

在startActivitySafely方法中执行了两步较为重要的逻辑

- 为Intent设置Flags,这样根Activity会在新的任务栈中启动 `intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);`
- 调用`startActivity(intent, optsBundle);`这个方法在Activity中实现,Launcher这个类就是继承于Activity的

> Activity类位于frameworks\base\core\java\android\app

```java
 	@Override
    public void startActivity(Intent intent, @Nullable Bundle options) {
        if (options != null) {
            startActivityForResult(intent, -1, options);
        } else {
            startActivityForResult(intent, -1);
        }
    }
```

在该方法中会调用startActivityForResult方法,第二个参数为-1,说明请求者不需要知道Activity的启动结果

startActivityForResult方法有很多个,我们使用最典型的来说明

` public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,@Nullable Bundle options)`

在这个方法中先执行了判断`if (mParent == null)` mParent是Activity类型,表示当前Activity的父类,因为目前根Activity还没有创建出来,所以mParent == null为true

之后调用了`mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options);`这个方法,Instrumentation主要是用来监控应用程序和系统的交互,在该方法中执行了以下代码

```java
ActivityManager.getService()
               .startActivity(whoThread, who.getBasePackageName(), intent,
                        intent.resolveTypeIfNeeded(who.getContentResolver()),
                        token, target != null ? target.mEmbeddedID : null,
                        requestCode, 0, null, options);
```

首先调用ActivityManager的getService来获得AMS的代理对象,之后使用AMS来执行startActivity方法,此处逻辑和Android8.0以前有些不同,8.0之前的版本是通过ActivityManagerNative的getDefault来获得AMS的代理对象,8.0之后将这个逻辑封装到了ActivityManager中而不是ActivityManagerNative中

在ActivityManager.getService方法中返回了`IActivityManagerSingleton.get();`,IActivityManagerSingleton是一个Singleton类,实例化如下

```java
    private static final Singleton<IActivityManager> IActivityManagerSingleton =
            new Singleton<IActivityManager>() {
                @Override
                protected IActivityManager create() {
                    //得到名为activity的Service引用,也就是IBinder类型的AMS引用
                    final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);
                    //将IBinder类型的AMS引用转换为IActivityManager类型的对象
                    final IActivityManager am = IActivityManager.Stub.asInterface(b);
                    return am;
                }
            };
```

将IBinder类型的AMS转换的类是采用了AIDL`Android Interface Definition Language` IActivityManager是由AIDL工具在编译时自动生成的,位于*frameworks\base\core\java\android\app*文件夹下,如果要实现进程间的通信,服务端(也就是AMS)只需要继承IActivityManager.Stud并实现相对的方法即可

>  [官方对于AIDL的解释](https://developer.android.com/guide/components/aidl?hl=zh-cn) 其主要使用过程为
>
> 1. 创建 .aidl 文件
>
>    此文件定义带有方法签名的编程接口。
>
> 2. 实现接口
>
>    Android SDK 工具会基于您的 `.aidl` 文件，使用 Java 编程语言生成接口。此接口拥有一个名为 `Stub` 的内部抽象类，用于扩展 `Binder` 类并实现 AIDL 接口中的方法。您必须扩展 `Stub` 类并实现这些方法。
>
> 3. 向客户端公开接口
>
>    实现 `Service` 并重写 `onBind()`，从而返回 `Stub` 类的实现。

## AMS到ApplicationThread的调用过程

Launcher请求AMS之后,代码就执行到了AMS部分,,AMS调用ApplicationThread的流程为

```mermaid
sequenceDiagram
	Instrumentation ->> AMS : startActivity
	activate  AMS
	AMS ->> AMS : startActivityAsUser
	AMS ->> ActivityStarter : startActivityMayWait
	deactivate AMS
	activate ActivityStarter
	ActivityStarter ->> ActivityStarter : startActivityLocked
	ActivityStarter ->> ActivityStarter : startActivity
	ActivityStarter ->> ActivityStarter : startActivity
	ActivityStarter ->> ActivityStarter : startActivityUnchecked
	ActivityStarter ->> ActivityStackSupervisor : resumeFocusedStackTopActivityLocked
	deactivate ActivityStarter
	activate ActivityStackSupervisor 
	ActivityStackSupervisor ->> ActivityStack : resumeTopActivityUncheckedLocked
	deactivate ActivityStackSupervisor
	activate ActivityStack
	ActivityStack ->> ActivityStack : resumeTopActivityInnerLocked
	ActivityStack ->> ActivityStackSupervisor : startSpecificActivityLocked
	deactivate ActivityStack
	activate ActivityStackSupervisor
	ActivityStackSupervisor ->> ActivityStackSupervisor : realStartActivityLocked
	ActivityStackSupervisor ->> ApplicationThread : realStartActivityLocked
	deactivate ActivityStackSupervisor
	activate ApplicationThread
	deactivate ApplicationThread
```

按照流程首先是`ActivityManagerService.startActivity`方法,*AMS位于frameworks\base\services\core\java\com\android\server\am*

`ActivityManagerService.startActivity`方法会执行以下代码片段

```java
startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,
                resultWho, requestCode, startFlags, profilerInfo, bOptions,
                UserHandle.getCallingUserId());
```

startActivityAsUser这个方法和startActivity方法相比多了一个`UserHandle.getCallingUserId()`参数,这个方法会获得调用者的UserId,AMS根据该UserId来确定调用者的身份

startActivityAsUser执行了以下行为

- 判断调用者进程是否被隔离 `enforceNotIsolatedCaller("startActivity");`,如果被隔离会抛出`SecurityException`异常

- 检测调查者权限`userId = mUserController.handleIncomingUser(Binder.getCallingPid(),Binder.getCallingUid(),userId, false, ALLOW_FULL_ONLY, "startActivity", null);` ,如果没有权限也抛出 `SecurityException`异常

- 调用ActivityStarter.startActivityMayWait方法

  ```java
  mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent,
                  resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,
                  profilerInfo, null, null, bOptions, false, userId, null,
  				//TaskRecord类型,代表启动的Activity所在的栈
  				null,                   
  				//表示启动的理由
                  "startActivityAsUser")
  ```
  
  > ActivityStarter是在Android7.0中新加入的类,是加载Activity的控制类,该类会收集所有的逻辑来决定如何将Intent和Flag转换为Activity,并且将Activity和Task以及Stack相关联

ActivityStarter.startActivityMayWait方法中执行了ActivityStarter.startActivityLocked方法

```java
startActivityLocked(caller, intent, null /*ephemeralIntent*/,
                            resolvedTypes[i], aInfo, null /*rInfo*/, null, null, resultTo, null, -1,
                            callingPid, callingUid, callingPackage,
                            realCallingPid, realCallingUid, 0,
                            options, false, componentSpecified, outActivity, null, null, reason);
```

在ActivityStarter.startActivityLocked方法中先判断启动理由`if (TextUtils.isEmpty(reason))` 如果为空就抛出IllegalArgumentException异常,之后调用ActivityStarter.ActivityStarter方法
